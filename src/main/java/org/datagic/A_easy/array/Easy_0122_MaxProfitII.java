package org.datagic.A_easy.array;

/**
 * Desc: 买卖股票的最佳时机 II
 * Author: datagic (云瞻)
 * CreateDate: 2020/7/17 4:58 下午
 * Blog: datagic.top
 * 公众号: datagator (大数据领航员)
 */
public class Easy_0122_MaxProfitII {
    /**
     * 题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
     * 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
     * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
     * ---------------------------------------------------------------------------------------------------------
     * 题目解析：可以当天购买，当天售卖。
     * ---------------------------------------------------------------------------------------------------------
     * 时间复杂度：O(n)  空间复杂度：O(1)
     * ---------------------------------------------------------------------------------------------------------
     * 题目解法：使用贪心算法，当明天收益为正的时候，卖掉，然后当日购买，当明天收益为负时，不卖。使用动态规划，
     */
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 1, 1, 2, 3, 3, 6, 4};
        // 贪心
        System.out.println(maxProfitGA(prices));
        // 动态规划
        System.out.println(maxProfitDP(prices));
    }

    // 贪心算法
    public static int maxProfitGA(int[] prices) {
        // 当交易不足2天时，无收益
        if (prices.length < 2) {
            return 0;
        }
        int profit = 0;
        // 遍历每一天，若连续下降，则不买卖；若连续上升，则每日进行买卖，每日利益之和等于最终利益；
        // 每日不稳定交易，明天-今天等于利润，利润为正值，则加和到总利润，利润为负值，则不加。
        // 利润为正值，说明在今天进行了购买，明天进行了卖出操作；利润为负值，则今天不会购买，明日是否购买看后日情况。
        for (int i = 1; i < prices.length; i++) {
            int temp = prices[i] - prices[i - 1];
            if (temp >= 0) {
                profit += temp;
            }
        }
        return profit;
    }

    // 动态规划
    public static int maxProfitDP(int[] prices) {
        int len = prices.length;
        if (len < 2) {
            // 当交易不足2天时，无收益
            return 0;
        }
        // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0
        // int[i][j]，i表示索引为i的那天，可以获得的最大利润；j表示索引为i的那天是否持有股票：0：持有现金，1：持有股票
        int[][] dp = new int[len][2];

        // 第1天，持有现金，不做购买，利润为0
        dp[0][0] = 0;
        // 第1天，持有股票，发生购买，利润为 负的购买股票金额 (用钱买了股票，目前无收益，利润为负值)
        dp[0][1] = -prices[0];

        // 从第二天开始到最后一天，分别计算持有股票和持有现金的总利润
        // 持有现金总利润计算：昨日获得的总利润与昨日持有股票
        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[len - 1][0];
    }
}